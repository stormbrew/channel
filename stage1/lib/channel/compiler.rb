module Channel
	# The compiler is responsible for transforming a program document into a series of commands.
	# It does this by searching the passed TupleSet for Tuples and turning them into StatementTuples,
	# which are a superset of the Tuples they're derived from and contain information about
	# execution. Notably, they will have transformed most operator combinations into reverse
	# polish notation and certain built in constructs (if, switch, etc) will be in a specialized
	# format.
	module Compiler
		class CompilerError < ChannelError
			attr_reader :tuple
			def initialize(tuple)
				@tuple = tuple
			end
		end
		
		OperatorInfo = Struct.new(:token, :precedence, :associativity, :arity, :method)
		pc = 0
		Operators = {
			[2, '.'] => OperatorInfo['.', pc, :rtl, 2, nil], # uses rhs
			[1, '.'] => OperatorInfo['.', pc, :rtl, 1, nil], # uses rhs
			[1, '+'] => OperatorInfo['+', pc+=1, :rtl, 1, Parser::Symbolic["+"]],
			[1, '-'] => OperatorInfo['-', pc, :rtl, 1, Parser::Symbolic["-"]],
			[1, '!'] => OperatorInfo['!', pc, :rtl, 1, Parser::BareWord["nil?"]],
			[1, '~'] => OperatorInfo['~', pc, :rtl, 1, Parser::Symbolic["~"]], # not sure what this'll do yet.
			[1, '*'] => OperatorInfo['*', pc, :rtl, 1, Parser::BareWord["expand"]], # needs special processing
			[2, '*'] => OperatorInfo['*', pc+=1, :ltr, 2, Parser::Symbolic["*"]],
			[2, '/'] => OperatorInfo['/', pc, :ltr, 2, Parser::Symbolic["/"]],
			[2, '%'] => OperatorInfo['%', pc, :ltr, 2, Parser::Symbolic["%"]],
			[2, '+'] => OperatorInfo['+', pc+=1, :ltr, 2, Parser::Symbolic["+"]],
			[2, '-'] => OperatorInfo['-', pc, :ltr, 2, Parser::Symbolic["-"]],
			[2, '..'] => OperatorInfo['..', pc+=1, :ltr, 2, Parser::BareWord["to"]],
			[2, '...'] => OperatorInfo['...', pc, :ltr, 2, Parser::BareWord["to"]],
			[2, '<<'] => OperatorInfo['<<', pc+=1, :ltr, 2, Parser::Symbolic["<<"]],
			[2, '>>'] => OperatorInfo['>>', pc, :ltr, 2, Parser::Symbolic[">>"]],
			[2, '<'] => OperatorInfo['<', pc+=1, :ltr, 2, Parser::Symbolic["<"]],
			[2, '>'] => OperatorInfo['>', pc, :ltr, 2, Parser::Symbolic[">"]],
			[2, '<='] => OperatorInfo['<=', pc, :ltr, 2, Parser::Symbolic["<="]],
			[2, '>='] => OperatorInfo['>=', pc, :ltr, 2, Parser::Symbolic[">="]],
			[2, '=='] => OperatorInfo['==', pc+=1, :ltr, 2, Parser::Symbolic["=="]],
			[2, '!='] => OperatorInfo['!=', pc, :ltr, 2, Parser::Symbolic["!="]], # convert to !(a==b)
			[2, '&'] => OperatorInfo['&', pc+=1, :ltr, 2, Parser::Symbolic["&"]], # not sure what this'll do yet
			[2, '^'] => OperatorInfo['^', pc+=1, :ltr, 2, Parser::Symbolic["^"]], # not sure what this'll do yet
			[2, '|'] => OperatorInfo['|', pc+=1, :ltr, 2, Parser::Symbolic["|"]], 
			[2, '&&'] => OperatorInfo['&&', pc+=1, :ltr, 2, Parser::Symbolic["&&"]], # handle specially
			[2, '||'] => OperatorInfo['||', pc+=1, :ltr, 2, Parser::Symbolic["||"]], # handle specially
		}
		class OperatorInfo
			# note that above the OperatorInfo#[] generated by Struct is used
			# to build the table, but here we alter it to a find function. This
			# is because building new OperatorInfo objects after this really shouldn't
			# happen, but a shorthand for getting operator info is very useful.
			def OperatorInfo.find(arity, text)
				return Operators[[arity, text]]
			end
			def OperatorInfo.[](arity, text)
				return Operators[[arity, text]]
			end
			def inspect_r(l = 0)
				return %Q{OperatorInfo[#{arity}, #{token.inspect_r}]}
			end
		end
		
		OperatorNode = Struct.new(:arity, :token)
		class OperatorNode
			def info()
				OperatorInfo[arity, token.string]
			end
		end
		
		# Provides baseline functionality for an object that compiles.
		class Compiler
			# The parser object this compiler was based on.
			attr_reader :parser
			
			def initialize()
				@parser = nil
			end
			def initialize_compiler(parser, *context)
				@parser = parser
			end
			def compile()
			end
			
			def inspect_r()
			end
			
			# Uses shunting yard algorithm to re-order operators and method calls
			# taking into account operator precedence rules so that it can be
			# easily consumed by the compilers.
			def Compiler.reorder_operators(parser)
				op_stack = []
				output = []
				
				# this is an implementation of the shunting yard algorithm. Note that it
				# outputs a polish notation, not reverse polish notation. The resulting
				# stack is consumed below into an actual execution graph.
				unary = true
				escape_operator = false
				parser.values.each {|val|
					op_info = nil
					if (val.kind_of?(Parser::Symbolic) &&
						  (op_info = OperatorInfo.find(unary ? 1 : 2, val.string)) &&
						  !escape_operator)
						last_op = op_stack.last
						if (last_op)
							while (last_op &&
								     ((op_info.associativity == :ltr && op_info.precedence >= last_op.info.precedence) ||
							       (op_info.associativity == :rtl && op_info.precedence > last_op.info.precedence)))
								output.unshift(op_stack.pop)
								last_op = op_stack.last
							end
						end
						op_stack.push(OperatorNode[op_info.arity, val])
						output.unshift(nil) # we're done a 'term' of the parse, so push a nil to act as a sequence point
						unary = true # operator after operator is unary
					else
						if (val == Parser::BareWord['operator'])
							escape_operator = true
						elsif (output.first.kind_of? Array)
							output.first.push(val)
							escape_operator = false
						else
							output.unshift([val])
							escape_operator = false
						end
						unary = false # operator after value is binary
					end
				}
				while (!op_stack.empty?)
					output.unshift(op_stack.pop)
				end
				return output.compact # remove nil sentinels.
			end
			
			def Compiler.compile(parser, *context)
				c = self.new
				c.initialize_compiler(parser, *context)
				c.compile
				return c
			end
			def Compiler.[](*args)
				self.new(*args)
			end
		end
		
		# A block of code, which is essentially a list of statements (which
		# are a tree of expressions). It maps roughly to a TupleSet in the
		# parser.
		class Block < Compiler
			attr_reader :statements
			
			def initialize(*statements)
				@statements = statements
			end
			def ==(other)
				other.kind_of?(Block) && @statements == other.statements
			end
			def compile()
				if (!parser.kind_of?(Parser::TupleSet))
					raise CompilerError.new(parser), "Block compiler expected a TupleSet, got #{parser.class}"
				end
				@statements = parser.tuples.collect {|tuple|
					Statement.compile(tuple)
				}
			end
		end
		
		# A statement is a single 'action' as defined by the author of the
		# code. Usually it correlates to a line of code. It maps roughly to
		# a Tuple in the parser.
		class Statement < Compiler
			attr_reader :root_expr
			
			def initialize(root_expr = nil)
				@root_expr = root_expr
			end
			def ==(other)
				other.kind_of?(Statement) && other.root_expr == root_expr
			end
			def compile()
				if (!parser.kind_of?(Parser::Tuple))
					raise CompilerError.new(parser), "Statement compiler expected a Tuple, got #{parser.class}"
				end

				output = Compiler.reorder_operators(parser)
				@root_expr = Expression.precompile(parser, output)
				
				if (!output.empty?)
					raise CompilerError(parser), "Statement contained values that the compiler couldn't consume."
				end
			end
		end
		
		# An expression is an atomic unit of execution. Conceptually,
		# every expression can be converted into a method call. The interpreter
		# may apply optimizations at its discretion, however.
		class Expression < Compiler
			# target and args are both capable of being either Values or Expressions,
			# but args will always be an array of whatever it is.
			attr_reader :target, :method, :args
			
			def initialize(target = nil, method = nil, args = [])
				@target = target
				@method = method
				@args = args
			end
			def ==(other)
				other.kind_of?(Expression) && other.target = target && other.method == method && other.args == args
			end
			def initialize_compiler(parser, compiled_terms)
				super(parser)
				@compiled_terms = compiled_terms
			end
			
			# does an initial step to determine if this is actually
			# an expression or a value and then does the compile step.
			def Expression.precompile(parser, output)
				if (!output.first.kind_of?(Array) || 
					  output.first.first.kind_of?(Parser::BareWord) ||
					  output.first.first.kind_of?(Parser::Symbolic))
					return Expression.compile(parser, output)
				else
					val = output.first.shift
					if (!output.first.empty?)
						raise CompilerError(val), "Value expression had more than one term"
					end
					return Value.compile(val)
				end
			end
			
			def compile()
				# if the first term is an array, that means
				# it's a plain old self-directed method call.
				# (ie. equiv to self.methodname)
				first = @compiled_terms.shift
				if (first.kind_of?(Array))
					@target = nil
					@method = first.shift
					# note that method args are always parsed as values and not
					# compiled. That's up to the method to deal with (but
					# from an end user perspective, it will be taken care of
					# by the runtime most of the time)
					@args = first.collect {|arg| Value.compile(arg) }
				elsif (first.kind_of?(OperatorNode))
					# operators (including .) work differently from bare method
					# invocations in that their operands *are* compiled immediately.
					# without this, there'd be ANARCHY I tells ya.
					if (first.info.method.nil?) # method invokation, @method will be the first value on the rhs.
						if (first.arity == 1) # self-method, @target is nil
							@target = nil
						else
							@target = Expression.precompile(first.token, @compiled_terms)
						end
						# get the rhs
						rhs = @compiled_terms.shift
						if (rhs.kind_of?(Array) && (rhs.first.kind_of?(Parser::BareWord) || rhs.first.kind_of?(Parser::Symbolic)))
							@method = rhs.shift
							@args = rhs.collect {|arg| Value.compile(arg) }
						else
							raise CompilerError.new(first.token), "Unexpected right hand side to method invoke. Must be a BareWord or Symbolic, got #{rhs.inspect}."
						end
					else # normal operator
						@target = Expression.precompile(first.token, @compiled_terms)
						@method = Parser::parse(first.method)
						if (first.arity > 1)
							@args = Expression.precompile(first.token, @compiled_terms)
						end
					end
				end
			end
			
			# A value is like an expression, but rather than being a
			# method call is some kind of a constant value embedded in the code.
			# ie. a string constant.
			class Value < Compiler
				attr_reader :value
				
				def initialize(value = nil)
					@value = value
				end
				
				def ==(other)
					other.kind_of?(Value) && other.value == value
				end
				
				def compile()
					@value = parser
				end
			end
		end
	end
	module Parser
		class TupleSet
			def compile()
				@compiled || (@compiled = Compiler::Block.compile(self))
			end
		end
		class Tuple
			def compile()
				@compiled || (@compiled = Compiler::Statement.compile(self))
			end
		end
	end
end