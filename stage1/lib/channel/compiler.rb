module Channel
	# The compiler is responsible for transforming a program document into a series of commands.
	# It does this by searching the passed TupleSet for Tuples and turning them into StatementTuples,
	# which are a superset of the Tuples they're derived from and contain information about
	# execution. Notably, they will have transformed most operator combinations into reverse
	# polish notation and certain built in constructs (if, switch, etc) will be in a specialized
	# format.
	module Compiler
		class CompilerError < ChannelError
			attr_reader :tuple
			def initialize(tuple)
				@tuple = tuple
			end
		end
		
		OperatorInfo = Struct.new(:token, :precedence, :associativity, :arity, :method)
		pc = 0
		Operators = {
			[2, '.'] => OperatorInfo['.', pc, :rtl, 2, nil], # uses rhs
			[1, '.'] => OperatorInfo['.', pc, :rtl, 1, nil], # uses rhs
			[1, '+'] => OperatorInfo['+', pc+=1, :rtl, 1, Parser::Symbolic["+"]],
			[1, '-'] => OperatorInfo['-', pc, :rtl, 1, Parser::Symbolic["-"]],
			[1, '!'] => OperatorInfo['!', pc, :rtl, 1, Parser::BareWord["nil?"]],
			[1, '~'] => OperatorInfo['~', pc, :rtl, 1, Parser::Symbolic["~"]], # not sure what this'll do yet.
			[1, '*'] => OperatorInfo['*', pc, :rtl, 1, Parser::BareWord["expand"]], # needs special processing
			[2, '*'] => OperatorInfo['*', pc+=1, :ltr, 2, Parser::Symbolic["*"]],
			[2, '/'] => OperatorInfo['/', pc, :ltr, 2, Parser::Symbolic["/"]],
			[2, '%'] => OperatorInfo['%', pc, :ltr, 2, Parser::Symbolic["%"]],
			[2, '+'] => OperatorInfo['+', pc+=1, :ltr, 2, Parser::Symbolic["+"]],
			[2, '-'] => OperatorInfo['-', pc, :ltr, 2, Parser::Symbolic["-"]],
			[2, '..'] => OperatorInfo['..', pc+=1, :ltr, 2, Parser::BareWord["to"]],
			[2, '...'] => OperatorInfo['...', pc, :ltr, 2, Parser::BareWord["to"]],
			[2, '<<'] => OperatorInfo['<<', pc+=1, :ltr, 2, Parser::Symbolic["<<"]],
			[2, '>>'] => OperatorInfo['>>', pc, :ltr, 2, Parser::Symbolic[">>"]],
			[2, '<'] => OperatorInfo['<', pc+=1, :ltr, 2, Parser::Symbolic["<"]],
			[2, '>'] => OperatorInfo['>', pc, :ltr, 2, Parser::Symbolic[">"]],
			[2, '<='] => OperatorInfo['<=', pc, :ltr, 2, Parser::Symbolic["<="]],
			[2, '>='] => OperatorInfo['>=', pc, :ltr, 2, Parser::Symbolic[">="]],
			[2, '=='] => OperatorInfo['==', pc+=1, :ltr, 2, Parser::Symbolic["=="]],
			[2, '!='] => OperatorInfo['!=', pc, :ltr, 2, Parser::Symbolic["!="]], # convert to !(a==b)
			[2, '&'] => OperatorInfo['&', pc+=1, :ltr, 2, Parser::Symbolic["&"]], # not sure what this'll do yet
			[2, '^'] => OperatorInfo['^', pc+=1, :ltr, 2, Parser::Symbolic["^"]], # not sure what this'll do yet
			[2, '|'] => OperatorInfo['|', pc+=1, :ltr, 2, Parser::Symbolic["|"]], 
			[2, '&&'] => OperatorInfo['&&', pc+=1, :ltr, 2, Parser::Symbolic["&&"]], # handle specially
			[2, '||'] => OperatorInfo['||', pc+=1, :ltr, 2, Parser::Symbolic["||"]], # handle specially
		}
		class OperatorInfo
			# note that above the OperatorInfo#[] generated by Struct is used
			# to build the table, but here we alter it to a find function. This
			# is because building new OperatorInfo objects after this really shouldn't
			# happen, but a shorthand for getting operator info is very useful.
			def OperatorInfo.find(arity, text)
				return Operators[[arity, text]]
			end
			def OperatorInfo.[](arity, text)
				return Operators[[arity, text]]
			end
			def inspect_r(l = 0)
				return %Q{#{" "*l}OperatorInfo[#{arity}, #{text.inspect_r}]}
			end
		end
		
		OperatorNode = Struct.new(:arity, :token)
		class OperatorNode
			def info()
				OperatorInfo[arity, token.string]
			end
			def inspect_r(l = 0)
				return %Q{#{" "*l}OperatorNode[#{arity}, #{token.inspect_r}]}
			end
		end
		
		# Provides baseline functionality for an object that compiles.
		class Compiler
			# The parser object this compiler was based on.
			attr_reader :parser
			
			def initialize()
				@parser = nil
			end
			def initialize_compiler(parser, *context)
				@parser = parser
			end
			def compile()
			end
			
			def inspect_r()
			end
			
			# Uses shunting yard algorithm to re-order operators and method calls
			# taking into account operator precedence rules so that it can be
			# easily consumed by the compilers.
			def Compiler.reorder_operators(parser)
				op_stack = []
				output = []
				
				# this is an implementation of the shunting yard algorithm. The resulting
				# stack is consumed below into an actual execution graph.
				unary = true
				escape_operator = false
				parser.values.each {|val|
					op_info = nil
					if (val.kind_of?(Parser::Symbolic) &&
						  (op_info = OperatorInfo.find(unary ? 1 : 2, val.string)) &&
						  !escape_operator)
						last_op = op_stack.last
						if (last_op)
							while (last_op &&
								     ((op_info.associativity == :ltr && op_info.precedence >= last_op.info.precedence) ||
							       (op_info.associativity == :rtl && op_info.precedence > last_op.info.precedence)))
								output.push(op_stack.pop)
								last_op = op_stack.last
							end
						end
						op_stack.push(OperatorNode[op_info.arity, val])
						output.push(nil) # we're done a 'term' of the parse, so push a nil to act as a sequence point
						unary = true # operator after operator is unary
					else
						if (val == Parser::BareWord['operator'])
							escape_operator = true
						elsif (output.last.kind_of? Array)
							output.last.push(val)
							escape_operator = false
						else
							output.push([val])
							escape_operator = false
						end
						unary = false # operator after value is binary
					end
				}
				while (!op_stack.empty?)
					output.push(op_stack.pop)
				end
				output.compact # remove nil sentinels.
			end
			
			def Compiler.compile(parser, *context)
				c = self.new
				c.initialize_compiler(parser, *context)
				c.compile
				return c
			end
			def Compiler.[](*args)
				self.new(*args)
			end
		end
		
		# A block of code, which is essentially a list of statements (which
		# are a tree of expressions). It maps roughly to a TupleSet in the
		# parser.
		class Block < Compiler
			attr_reader :statements
			
			def initialize(*statements)
				@statements = statements
			end
			def ==(other)
				other.kind_of?(Block) && @statements == other.statements
			end
			def compile()
				if (!parser.kind_of?(Parser::TupleSet))
					raise CompilerError.new(parser), "Block compiler expected a TupleSet, got #{parser.class}"
				end
				@statements = parser.tuples.collect {|tuple|
					Statement.compile(tuple)
				}
			end
			
			def inspect_r(l = 0)
				t = " "*l
				s = ""
				s << t << "Block[\n"
				s << statements.collect {|i| i.inspect_r(l+1) }.join(",\n") << "\n"
				s << t << "]"
			end
		end
		
		# A statement is a single 'action' as defined by the author of the
		# code. Usually it correlates to a line of code. It maps roughly to
		# a Tuple in the parser.
		class Statement < Compiler
			attr_reader :root_expr
			
			def initialize(root_expr = nil)
				@root_expr = root_expr
			end
			def ==(other)
				other.kind_of?(Statement) && other.root_expr == root_expr
			end
			def compile()
				if (!parser.kind_of?(Parser::Tuple))
					raise CompilerError.new(parser), "Statement compiler expected a Tuple, got #{parser.class}"
				end

				stack = []
				output = Compiler.reorder_operators(parser)
				output.each {|node|
					if (!node.kind_of?(Array))
						stack.push(Expression.compile(parser, node, stack))
					else
						stack.push(node)
					end
				}
				
				if (stack.length != 1)
					raise CompilerError.new(parser), "Statement did not produce a single expression. Parse stack:\n#{stack.inspect_r(1)}"
				end
				
				if (stack.first.kind_of?(Array))
					node = stack.first
					case node.first
					when Parser::BareWord, Parser::Symbolic
						@root_expr = Expression.compile(node.first, node)
					else
						@root_expr = Value.compile(node.shift)
					end
				else
					@root_expr = stack.pop
				end
			end
			def inspect_r(l = 0)
				t = " "*l
				s = ""
				s << t << "Statement[\n"
				s << @root_expr.inspect_r(l+1) << "\n"
				s << t << "]"
			end
		end
		
		# An expression is an atomic unit of execution. Conceptually,
		# every expression can be converted into a method call. The interpreter
		# may apply optimizations at its discretion, however.
		class Expression < Compiler
			# target and args are both capable of being either Values or Expressions,
			# but args will always be an array of whatever it is.
			attr_reader :target, :method, :args
			
			def initialize(target = nil, method = nil, args = [])
				@target = target
				@method = method
				@args = args
			end
			def ==(other)
				other.kind_of?(Expression) && other.target = target && other.method == method && other.args == args
			end
			def initialize_compiler(parser, node, arg_stack = [])
				super(parser)
				@node = node
				@arg_stack = arg_stack
			end
			
			def compile()
				# if the first term is an array, that means
				# it's a plain old self-directed method call.
				# (ie. equiv to self.methodname)
				if (@node.kind_of?(Array))
					@target = nil
					@method = @node.shift
					# note that method args are always parsed as values and not
					# compiled. That's up to the method to deal with (but
					# from an end user perspective, it will be taken care of
					# by the runtime most of the time)
					@args = @node.collect {|arg| Value.compile(arg) }
				elsif (@node.kind_of?(OperatorNode))
					# operators (including .) work differently from bare method
					# invocations in that their operands *are* compiled immediately.
					# without this, there'd be ANARCHY I tells ya.
					if (@node.info.method.nil?) # method invokation, @method will be the first value on the rhs.
						if (@node.arity == 1) # self-method, @target is nil
							@target = nil
						else
							@target = dispatch_value(@arg_stack.pop || raise(CompilerError.new(@node.token), "Could not parse method call with no target."))
						end
						# get the rhs
						rhs = @arg_stack.pop
						if (rhs.kind_of?(Array) && (rhs.first.kind_of?(Parser::BareWord) || rhs.first.kind_of?(Parser::Symbolic)))
							@method = rhs.pop
							@args = rhs.collect {|arg| Value.compile(arg) }
						else
							raise CompilerError.new(@node.token), "Unexpected right hand side to method invoke. Must be a BareWord or Symbolic, got:\n#{rhs.inspect_r(1)}."
						end
					else # normal operator
						@target = dispatch_value(@arg_stack.pop || raise(CompilerError.new(@node.token), "Could not parse method call with no target."))
						@method = @node.info.method
						if (@node.arity == 2)
							@args = [dispatch_value(@arg_stack.pop || raise(CompilerError.new(@node.token), "Could not parse method call with no target."))]
						end
					end
				end
			end
			
			# this is to deal with the fact that under certain
			# circumstances, what looks like a value is actually a method
			def dispatch_value(node)
				if (node.kind_of?(Array))
					if (node.first.kind_of?(Parser::BareWord) || node.first.kind_of?(Parser::Symbolic))
						return Expression.compile(parser, node, [])
					else
						val = node.shift
						if (!node.empty?)
							raise CompilerError(val), "Value expression had more than one term"
						end
						return Value.compile(val)
					end
				else
					return node
				end
			end
					
			
			def inspect_r(l = 0)
				t = " "*l
				s = ""
				s << t << "Expression[\n"
				s << target.inspect_r(l+1) << ",\n"
				s << method.inspect_r(l+1) << ",\n"
				s << args.inspect_r(l+1) << "\n"
				s << t << "]"
			end
		end
		
		# A value is like an expression, but rather than being a
		# method call is some kind of a constant value embedded in the code.
		# ie. a string constant.
		class Value < Compiler
			attr_reader :value
			
			def initialize(value = nil)
				@value = value
			end
			
			def ==(other)
				other.kind_of?(Value) && other.value == value
			end
			
			def compile()
				@value = parser
			end
			def inspect_r(l = 0)
				t = " "*l
				s = ""
				s << t << "Value[\n"
				s << value.inspect_r(l+1) << "\n"
				s << t << "]"
			end
		end
	end
	module Parser
		class TupleSet
			def compile()
				@compiled || (@compiled = Compiler::Block.compile(self))
			end
		end
		class Tuple
			def compile()
				@compiled || (@compiled = Compiler::Statement.compile(self))
			end
		end
	end
end