module Channel
	# The compiler is responsible for transforming a program document into a series of commands.
	# It does this by searching the passed TupleSet for Tuples and turning them into StatementTuples,
	# which are a superset of the Tuples they're derived from and contain information about
	# execution. Notably, they will have transformed most operator combinations into reverse
	# polish notation and certain built in constructs (if, switch, etc) will be in a specialized
	# format.
	module Compiler
		class CompilerError < ChannelError
			attr_reader :tuple
			def initialize(tuple)
				@tuple = tuple
			end
		end
		
		OperatorInfo = Struct.new(:token, :precedence, :associativity, :arity, :method)
		pc = 0
		Operators = {
			[2, '.'] => OperatorInfo['.', pc, :ltr, 2, nil], # uses rhs
			[1, '.'] => OperatorInfo['.', pc, :ltr, 1, nil], # uses rhs
			[1, '+'] => OperatorInfo['+', pc+=1, :rtl, 1, Parser::Symbolic["+"]],
			[1, '-'] => OperatorInfo['-', pc, :rtl, 1, Parser::Symbolic["-"]],
			[1, '!'] => OperatorInfo['!', pc, :rtl, 1, Parser::BareWord["nil?"]],
			[1, '~'] => OperatorInfo['~', pc, :rtl, 1, nil], # not sure what this'll do yet.
			[1, '*'] => OperatorInfo['*', pc, :rtl, 1, nil], # needs special processing
			[2, '*'] => OperatorInfo['*', pc+=1, :ltr, 2, Parser::Symbolic["*"]],
			[2, '/'] => OperatorInfo['/', pc, :ltr, 2, Parser::Symbolic["/"]],
			[2, '%'] => OperatorInfo['%', pc, :ltr, 2, Parser::Symbolic["%"]],
			[2, '+'] => OperatorInfo['+', pc+=1, :ltr, 2, Parser::Symbolic["+"]],
			[2, '-'] => OperatorInfo['-', pc, :ltr, 2, Parser::Symbolic["-"]],
			[2, '..'] => OperatorInfo['..', pc+=1, :ltr, 2, Parser::BareWord["to"]],
			[2, '...'] => OperatorInfo['...', pc, :ltr, 2, Parser::BareWord["to"]],
			[2, '<<'] => OperatorInfo['<<', pc+=1, :ltr, 2, Parser::Symbolic["<<"]],
			[2, '>>'] => OperatorInfo['>>', pc, :ltr, 2, Parser::Symbolic[">>"]],
			[2, '<'] => OperatorInfo['<', pc+=1, :ltr, 2, Parser::Symbolic["<"]],
			[2, '>'] => OperatorInfo['>', pc, :ltr, 2, Parser::Symbolic[">"]],
			[2, '<='] => OperatorInfo['<=', pc, :ltr, 2, Parser::Symbolic["<="]],
			[2, '>='] => OperatorInfo['>=', pc, :ltr, 2, Parser::Symbolic[">="]],
			[2, '=='] => OperatorInfo['==', pc+=1, :ltr, 2, Parser::Symbolic["=="]],
			[2, '!='] => OperatorInfo['!=', pc, :ltr, 2, nil], # convert to !(a==b)
			[2, '&'] => OperatorInfo['&', pc+=1, :ltr, 2, nil], # not sure what this'll do yet
			[2, '^'] => OperatorInfo['^', pc+=1, :ltr, 2, nil], # not sure what this'll do yet
			[2, '|'] => OperatorInfo['|', pc+=1, :ltr, 2, Parser::Symbolic["|"]], 
			[2, '&&'] => OperatorInfo['&&', pc+=1, :ltr, 2, nil], # handle specially
			[2, '||'] => OperatorInfo['||', pc+=1, :ltr, 2, nil], # handle specially
		}
		class OperatorInfo
			# note that above the OperatorInfo#[] generated by Struct is used
			# to build the table, but here we alter it to a find function. This
			# is because building new OperatorInfo objects after this really shouldn't
			# happen, but a shorthand for getting operator info is very useful.
			def OperatorInfo.[](arity, text)
				return Operators[[arity, text]]
			end
			def inspect_r(l = 0)
				return %Q{OperatorInfo[#{arity}, #{token.inspect_r}]}
			end
		end
		
		# Provides baseline functionality for an object that compiles.
		class Compiler
			# The parser object this compiler was based on.
			attr_reader :parser
			
			def initialize()
				@parser = nil
			end
			def initialize_compiler(parser, *context)
				@parser = parser
			end
			def compile()
			end
			
			def inspect_r()
			end
			
			def Compiler.compile(parser, *context)
				c = self.new
				c.initialize_compiler(parser, *context).compile
				return c
			end
			def Compiler.[](*args)
				self.new(*args)
			end
		end
		
		# A block of code, which is essentially a list of statements (which
		# are a tree of expressions). It maps roughly to a TupleSet in the
		# parser.
		class Block < Compiler
			attr_reader :statements
			
			def initialize(*statements)
				@statements = statements
			end
			def compile()
				if (!parser.kind_of?(Parser::TupleSet))
					raise CompilerError.new(parser), "Block compiler expected a TupleSet, got #{parser.class}"
				end
				@statements = parser.collect {|tuple|
					Statement.compile(tuple)
				}
			end
		end
		
		# A statement is a single 'action' as defined by the author of the
		# code. Usually it correlates to a line of code. It maps roughly to
		# a Tuple in the parser.
		class Statement < Compiler
			attr_reader :root_expr
			
			def initialize(root_expr)
				@root_expr = root_expr
			end
			def compile()
				if (!parser.kind_of?(Parser::Tuple))
					raise CompilerError.new(parser), "Statement compiler expected a Tuple, got #{parser.class}"
				end
				
				op_stack = []
				output = []
				
				# this is an implementation of the shunting yard algorithm. Note that it
				# outputs a polish notation, not reverse polish notation. The resulting
				# stack is consumed below into an actual execution graph.
				unary = true
				escape_operator = false
				parser.values.each {|val|
					op_info = nil
					if (val.kind_of?(Parser::Symbolic) &&
						  op_info = OperatorInfo.find(unary ? 1 : 2, val.string) &&
						  !escape_operator)
						last_op = op_stack.last
						if (last_op)
							while (last_op &&
								     ((op_info.associativity == :ltr && op_info.precedence >= last_op.info.precedence) ||
							       (op_info.associativity == :rtl && op_info.precedence > last_op.info.precedence)))
								output.unshift(op_stack.pop)
								last_op = op_stack.last
							end
						end
						op_stack.push(OperatorNode[val, op_info.arity])
						output.unshift(nil) # we're done a 'term' of the parse, so push a nil to act as a sequence point
						unary = true # operator after operator is unary
					else
						if (val == Parser::BareWord['operator'])
							escape_operator = true
						elsif (output.last.kind_of? Array)
							output.first.push(val)
							escape_operator = false
						else
							output.unshift([val])
							escape_operator = false
						end
						unary = false # operator after value is binary
					end
				}
				while (!op_stack.empty?)
					output.unshift(op_stack.pop)
				end
				output.compact! # remove nil sentinels.
				
				if (output.count == 1 && output.kind_of?(Array))
					@root_expr = MethodInvokeExpression.compile(output.first.first, output.first)
				elsif (output.first.kind_of?(OperatorNode))
					op = output.shift
					info = OperatorInfo[op.arity, op.token.string]
					if (!info.method.nil?)
						args = []
						
						@root_expr = MethodInvokeExpression.compile(op.token, [info.method] + )
				
				# do some processing of the tuple:
				# - group the values between operators into sub-tuples
				# - make operators into OperatorNode objects.
				# - escape pairs of [BareWord["operator"], Symbolic[x]] into SymbolValueNode[x]
				orig_values = parser.values.dup
				cleaned_values = []
				while (!orig_values.empty?)
					val = orig_values.shift
					if (val.kind_of?(Symbolic) && (OperatorInfo[1, val.string] || OperatorInfo[2, val.string]))
						# it's an operator of some sort, so make it a SymbolValueNode and push it on.
						cleaned_values.push(OperatorNode.new(val))
						
					end
				end
			end
		end
		
		# An expression is an atomic unit of execution. It can be a function
		# call, an operator expression, etc.
		class Expression < Compiler
			
		end
		
		OperatorNode = Struct.new(:arity, :token)
	end
end